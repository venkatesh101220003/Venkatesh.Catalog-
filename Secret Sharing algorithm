import java.io.FileReader;
import java.io.IOException;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.Map;

import org.json.simple.JSONObject;  
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

public class ShamirSecretSharing {

    public static void main(String[] args) {
        try {
            // Read the JSON file
            JSONParser parser = new JSONParser();
            JSONObject jsonObject = (JSONObject) parser.parse(new FileReader("test_case.json"));

            // Iterate through each test case
            for (Object key : jsonObject.keySet()) {
                if (key.toString().equals("keys")) continue; // Skip the "keys" entry

                JSONObject testCase = (JSONObject) jsonObject.get(key);
                int k = Integer.parseInt(((JSONObject) testCase.get("keys")).get("k").toString());
                Map<Integer, BigInteger> points = parsePoints(testCase);

                // Calculate the secret using Lagrange interpolation
                BigInteger secret = calculateSecret(points, k);

                System.out.println("Secret for Test Case " + key + ": " + secret);
            }

        } catch (IOException | ParseException e) {
            e.printStackTrace();
        }
    }

    private static Map<Integer, BigInteger> parsePoints(JSONObject testCase) {
        Map<Integer, BigInteger> points = new HashMap<>();
        for (Object pointKey : testCase.keySet()) {
            if (pointKey.toString().equals("keys")) continue; // Skip the "keys" entry
            JSONObject point = (JSONObject) testCase.get(pointKey);
            int x = Integer.parseInt(pointKey.toString());
            String yStr = point.get("value").toString();
            int base = Integer.parseInt(point.get("base").toString());
            BigInteger y = new BigInteger(yStr, base);
            points.put(x, y);
        }
        return points;
    }

    private static BigInteger calculateSecret(Map<Integer, BigInteger> points, int k) {
        BigInteger secret = BigInteger.ZERO;
        for (Map.Entry<Integer, BigInteger> point1 : points.entrySet()) {
            int x1 = point1.getKey();
            BigInteger y1 = point1.getValue();
            BigInteger numerator = BigInteger.ONE;
            BigInteger denominator = BigInteger.ONE;
            for (Map.Entry<Integer, BigInteger> point2 : points.entrySet()) {
                int x2 = point2.getKey();
                if (x1 != x2) {
                    numerator = numerator.multiply(BigInteger.valueOf(-x2));
                    denominator = denominator.multiply(BigInteger.valueOf(x1 - x2));
                }
            }
            secret = secret.add(y1.multiply(numerator).divide(denominator));
        }
        return secret;
    }
}
